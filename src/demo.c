#include "network.h"
#include "detection_layer.h"
#include "region_layer.h"
#include "cost_layer.h"
#include "utils.h"
#include "parser.h"
#include "box.h"
#include "image.h"
#include "demo.h"
#include <sys/time.h>

#define FRAMES 3

#ifdef OPENCV
#include "opencv2/highgui/highgui_c.h"
#include "opencv2/imgproc/imgproc_c.h"
#include "opencv2/opencv.hpp"
//#include "opencv2/imgproc/imgproc.hpp"
#include "opencv2/video/video.hpp"
//C
#include <stdio.h>
//C++
#include <iostream>
#include <sstream>

using namespace cv;
using namespace std;
//image get_image_from_stream(CvCapture *cap);
image get_image_from_stream(IplImage *src);

static char **demo_names;
static image **demo_alphabet;
static int demo_classes;

static float **probs;
static box *boxes;
static network net;
static image in   ;
static IplImage *src;
static image in_s ;
static image det  ;
static image det_s;
static image disp = {0};
static CvCapture * cap;
//static VideoCapture cap1; 
static float fps = 0;
static float demo_thresh = 0;
static float demo_hier_thresh = .5;

static float *predictions[FRAMES];
static int demo_index = 0;
static image images[FRAMES];
static float *avg;
//an int array to store occupant number in the image of a video
static int *countpv;
static int countp;
// the total areas of boxes for detected persons
static int total_area;
//write to the file
static FILE *output;
//count the total frame
static int count_f;
// count the active frame
static int is_active=0;

// Global variables for background subtraction
Mat frame1; //current frame
Mat fgMaskMOG2; //fg mask fg mask generated by MOG2 method
Ptr<BackgroundSubtractor> pMOG2; //MOG2 Background subtractor
char keyboard; //input from keyboard
int history = 1;
float varThreshold = 16;
bool bShadowDetection = false;

void *fetch_in_thread(void *ptr)
{
    src = cvQueryFrame(cap);
    frame1 = cvarrToMat(src);
    in = get_image_from_stream(src);
    //img = cvQueryFrame(cap);
    if(!in.data){
        fprintf(output,"The number of total frames:%d\n",count_f);
        fclose(output);
        //activity level calssification
        if(is_active > count_f* .75)
            printf("This sample is classified as acitve!!\n");
        else 
            printf("This sample is classified as nonactive!!\n");
        
        error("Stream closed.");
    }
    in_s = resize_image(in, net.w, net.h);
    return 0;
}

void *detect_in_thread(void *ptr)
{
    float nms = .4;

    layer l = net.layers[net.n-1];
    float *X = det_s.data;
    float *prediction = network_predict(net, X);

    memcpy(predictions[demo_index], prediction, l.outputs*sizeof(float));
    mean_arrays(predictions, FRAMES, l.outputs, avg);
    l.output = avg;

    free_image(det_s);
    if(l.type == DETECTION){
        get_detection_boxes(l, 1, 1, demo_thresh, probs, boxes, 0);
    } else if (l.type == REGION){
        get_region_boxes(l, 1, 1, demo_thresh, probs, boxes, 0, 0, demo_hier_thresh);
    } else {
        error("Last layer must produce detections\n");
    }
    if (nms > 0) do_nms(boxes, probs, l.w*l.h*l.n, l.classes, nms);
    printf("\033[2J");
    printf("\033[1;1H");
    printf("\nFPS:%.1f\n",fps);
    printf("Objects:\n\n");

    images[demo_index] = det;
    det = images[(demo_index + FRAMES/2 + 1)%FRAMES];
    demo_index = (demo_index + 1)%FRAMES;

    countp=0;
    total_area=0;
    draw_detections(det, l.w*l.h*l.n, demo_thresh, boxes, probs, demo_names, demo_alphabet, demo_classes,&countp,&total_area);

    //img = cvQueryFrame(cap);
    //printf("correct?\n");
    //frame1 = cvarrToMat(img);
    //printf("correct?\n");
    //pMOG2->operator()(frame1,fgMaskMOG2);
    //printf("correct?\n");
   // int total_pixel = fgMaskMOG2.rows * fgMaskMOG2.cols;
   // int zero_pixel = total_pixel - countNonZero(fgMaskMOG2);
   // double percent = (double)zero_pixel / (double)total_area;
    //printf("percent of foreground:%f\n",percent);
    //if(percent > 0.75)
     // is_active++;
    return 0;
}
// add background subtraction as a thread & change demo.h
void *bg_sub_in_thread(void *ptr){

     //if(!cap1.isOpened()){
        //error in opening the video input
       // cerr << "Unable to open video file: " << cap << endl;
       // exit(EXIT_FAILURE);
    //}
    //read input data. ESC or 'q' for quitting
    //keyboard = 0;
    //while( keyboard != 'q' && keyboard != 27 ){
        //read the current frame
      //  if(!cap1.read(frame)) {
        //    cerr << "Unable to read next frame." << endl;
        //    cerr << "Exiting..." << endl;
        //    exit(EXIT_FAILURE);
        //}
    //IplImage *img = cvQueryFrame(cap);
    //frame1 = cvarrToMat(src);
    //update the background model
        //pMOG2->apply(frame, fgMaskMOG2);
        //printf("correct?\n");
        pMOG2->operator()(frame1,fgMaskMOG2);
        //printf("correct?\n");
        int total_pixel = fgMaskMOG2.rows * fgMaskMOG2.cols;
        //int zero_pixel = total_pixel - countNonZero(fgMaskMOG2);
        // percent of foreground with detected people based on areas of all detected persons
        double percent = (double) countNonZero(fgMaskMOG2) / (double) total_area; 
        printf("percent of foreground: %f\n",percent);
        //to do, evaluation metrics => if...
        if(percent > 0.75)
            is_active ++;
    //}
    return 0;
}

double get_wall_time()
{
    struct timeval time;
    if (gettimeofday(&time,NULL)){
        return 0;
    }
    return (double)time.tv_sec + (double)time.tv_usec * .000001;
}

void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, float hier_thresh)
{
    
    image **alphabet = load_alphabet();
    int delay = frame_skip;
    demo_names = names;
    demo_alphabet = alphabet;
    demo_classes = classes;
    demo_thresh = thresh;
    demo_hier_thresh = hier_thresh;
    printf("Demo\n");
    net = parse_network_cfg(cfgfile);
    //frame number
    int frame;
    if(weightfile){
        load_weights(&net, weightfile);
    }
    set_batch_network(&net, 1);

    srand(2222222);

    if(filename){
        printf("video file: %s\n", filename);
        cap = cvCaptureFromFile(filename);
        //cap1 = VideoCapture(filename);
        //the total frames of the video
        frame = (int)cvGetCaptureProperty(cap,CV_CAP_PROP_FRAME_COUNT);
        //allocate the array by doubling the frame number
        countpv = (int*)calloc(2*frame,sizeof(int));
    }else{
        cap = cvCaptureFromCAM(cam_index);
    }

    if(!cap) error("Couldn't connect to webcam.\n");

    layer l = net.layers[net.n-1];
    int j;

    avg = (float *) calloc(l.outputs, sizeof(float));
    for(j = 0; j < FRAMES; ++j) predictions[j] = (float *) calloc(l.outputs, sizeof(float));
    for(j = 0; j < FRAMES; ++j) images[j] = make_image(1,1,3);

    boxes = (box *)calloc(l.w*l.h*l.n, sizeof(box));
    probs = (float **)calloc(l.w*l.h*l.n, sizeof(float *));
    for(j = 0; j < l.w*l.h*l.n; ++j) probs[j] = (float *)calloc(l.classes, sizeof(float));

    pthread_t fetch_thread;
    pthread_t detect_thread;
    pthread_t bg_sub_thread;

    fetch_in_thread(0);
    det = in;
    det_s = in_s;

    fetch_in_thread(0);
    detect_in_thread(0);
    disp = det;
    det = in;
    det_s = in_s;

    for(j = 0; j < FRAMES/2; ++j){
        fetch_in_thread(0);
        detect_in_thread(0);
        disp = det;
        det = in;
        det_s = in_s;
    }

    int count = 0;
    count_f = 0;
    if(!prefix){
        cvNamedWindow("Demo", CV_WINDOW_NORMAL);
        cvMoveWindow("Demo", 0, 0);
        cvResizeWindow("Demo", 1352, 1013);
    }

    double before = get_wall_time();
    //FILE *output;
    //char *outputname="count.txt";
    output = fopen("count.txt","w+");
    //background subtractor
    pMOG2 = new BackgroundSubtractorMOG2(history,varThreshold,bShadowDetection); //MOG2 approach

    while(1){
        ++count;
        ++count_f;
        //printf("frame ID:%d\n",count);
        if(1){
            if(pthread_create(&fetch_thread, 0, fetch_in_thread, 0)) error("Thread creation failed");
            //if(count%4==0){
                if(pthread_create(&detect_thread, 0, detect_in_thread, 0)) error("Thread creation failed");
            //}
            if(pthread_create(&bg_sub_thread, 0, bg_sub_in_thread, 0)) error("Thread creation failed");

            //store number of people
            printf("the number of people:%d\n",countp);
            countpv[count]=countp;
            fprintf(output,"%d\n",countp);
            // show the total area of occupants
            printf("the total area of people:%d\n",total_area);

            if(!prefix){
                show_image(disp, "Demo");
                int c = cvWaitKey(1);
                //printf("c is %d\n",c);
                if (c == 10){
                    if(frame_skip == 0) frame_skip = 60;
                    else if(frame_skip == 4) frame_skip = 0;
                    else if(frame_skip == 60) frame_skip = 4;
                    else frame_skip = 0;
                }
            }else{
                char buff[256];
                sprintf(buff, "%s_%08d", prefix, count);
                save_image(disp, buff);
            }
        
            pthread_join(fetch_thread, 0);
            //printf("correct?\n");
            //if(count%2==0){
            pthread_join(detect_thread, 0);
            //}
            pthread_join(bg_sub_thread,0);

            if(delay == 0){
                free_image(disp);
                disp  = det;
            }
            det   = in;
            det_s = in_s;
        }else {
            fetch_in_thread(0);
            det   = in;
            det_s = in_s;
            detect_in_thread(0);
            if(delay == 0) {
                free_image(disp);
                disp = det;
            }
            show_image(disp, "Demo");
            cvWaitKey(1);
        }
        --delay;
        if(delay < 0){
            delay = frame_skip;

            double after = get_wall_time();
            float curr = 1./(after - before);
            fps = curr;
            before = after;
        }
    }
//    fclose(output);
    //save occupant number into .txt
    //FILE *output;
    //char *outputname="count.txt";
    //output = fopen(outputname,"w+");
    //int i;
    //for(i=1;i<=frame;i++)
      //  fprintf(output,"%d\n",countpv[i]);
    //printf("save to count.txt");
    //fclose(output);
    free(countpv);
}
#else
void demo(char *cfgfile, char *weightfile, float thresh, int cam_index, const char *filename, char **names, int classes, int frame_skip, char *prefix, float hier_thresh)
{
    fprintf(stderr, "Demo needs OpenCV for webcam images.\n");
}
#endif

